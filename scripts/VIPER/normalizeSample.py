#!/usr/bin/env	python

from optparse import OptionParser
parser = OptionParser()
(opts, args) = parser.parse_args()
import os

from scipy.stats import norm
from math import log
import numpy as np
   

def parseMatrix(file, test_sample=None, transpose=True):
	''' 
		Sample IDS should be the header line. Gene ids are the row names
		
		Input:
			binary_threshold: 'include data values only if they fall above this range (abs val)
			tf_parents: 

		Options:
			transpose: index by rows, then columns, instead of the default column/row spec
			
	'''


	# indexed by sample then by gene	
	data = {}

	test_sample_id = None
	test_sample_data = None
	row = 1
	first = True
	sampleIDS = None
	for line in open(file, 'r'):
		parts = line.rstrip().split("\t")
		row_id = parts[0]

		vals = parts[1:]
		if first:
			first = False
			column_ids = vals
			continue


		# save the sample id from the (first) row
		if row == test_sample:

			test_sample_id = row_id
			print test_sample_id
			test_sample_data = {}
			test_sample_data[row_id] = {}
			vals = parts[1:]
			for i in range(0,len(vals)):
				val = None
				try:
					val = float(vals[i])
				except:
					continue
				column_id = column_ids[i]		
				test_sample_data[row_id][column_id] = val

			row += 1
			continue
	
		for i in range(0,len(vals)):
			val = None
			try:
				val = float(vals[i])
			except:
				continue
			column_id = column_ids[i]		

			if column_id not in data:
				data[column_id] = {}
			data[column_id][row_id] = val

		row += 1

	return (data, test_sample_data) 

class Dist: 

	"""
	This class holds various parameterized distributions used to fit empirical data
	generated by background models used by the TieDIE algorithm. 
	"""

	def __init__(self, training_data, method="gaussian"):

		self.fit = {}
		if method == "gaussian":
			self.fitNorm(training_data)


	@staticmethod
	def fitLogNorm(vector, test_value):
		"""
			Fit a log-normal to the background distrubtion supplied. 
			Get the p-value based on the log of the test value. 

			Input:
				vector: background distribution to fit
				test_value: value to test against the fitted background distribution

			Output:
				A p-value based on that distribution	
		"""
		EPSILON = 0.00001
		mean, sd = norm.fit([log(v+EPSILON) for v in vector])		
		# just the cdf: this value should be smaller 
		p_val = norm.cdf(log(test_value+EPSILON), loc=mean,scale=sd)		

		return p_val

	def fitNorm(self, vector):
		"""
			Fit a normal to the background distrubtion supplied. 

			Input:
				vector: background distribution to fit

		"""
		EPSILON = 0.00001
		mean, sd = norm.fit([float(v)+EPSILON for v in vector])		
		self.mean = mean
		self.sd = sd

	def getP(self, test_value):

		EPSILON = 0.001
		# 1-tailed p-value...
		p_val = norm.cdf(test_value+EPSILON, loc=self.mean, scale=self.sd)		
		return p_val
		
	def getZ(self, test_value):

		EPSILON = 0.001
		z_score = (test_value - self.mean) / self.sd
		return z_score

data_bygene, test_sample_data = parseMatrix(args[0], test_sample=1, transpose=False)

for sample in test_sample_data:
	for gene in test_sample_data[sample]:

		test_value = test_sample_data[sample][gene]

		ref_values = []
		for ref_sample in data_bygene[gene]:
			ref_values.append(data_bygene[gene][ref_sample])

		gaus_dist = Dist(ref_values)
		p = gaus_dist.getP(test_value)
		if p < 0.05:
			print gene+'\t+'
		elif p > 0.95:
			print gene+'\t-'
